<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Determining people’s sleep state from wrist-worn accelerometer data">

<title>sleep_state_detection</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="sleep_state_detection">
<meta property="og:description" content="Determining people’s sleep state from wrist-worn accelerometer data">
<meta property="og:site_name" content="sleep_state_detection">
<meta name="twitter:title" content="sleep_state_detection">
<meta name="twitter:description" content="Determining people’s sleep state from wrist-worn accelerometer data">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">sleep_state_detection</span>
    </a>
  </div>
        <div class="quarto-navbar-tools">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./index.html">sleep_state_detection</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">sleep_state_detection</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./core-copy3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">core</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./core.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">core</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./eda_plotting_features_and_events.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">EDA</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./conf.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Configurations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./utils.common.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">utils.common</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./utils.metrics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">utils.metrics</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./post_process.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">post_process</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./prepare_data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">prepare_data</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#problem-we-need-to-efficiently-track-sleep-states" id="toc-problem-we-need-to-efficiently-track-sleep-states" class="nav-link active" data-scroll-target="#problem-we-need-to-efficiently-track-sleep-states">Problem: We need to efficiently track sleep states</a></li>
  <li><a href="#deliverables" id="toc-deliverables" class="nav-link" data-scroll-target="#deliverables">Deliverables</a></li>
  <li><a href="#stakeholders" id="toc-stakeholders" class="nav-link" data-scroll-target="#stakeholders">Stakeholders</a></li>
  <li><a href="#proposed-solution" id="toc-proposed-solution" class="nav-link" data-scroll-target="#proposed-solution">Proposed solution:</a>
  <ul class="collapse">
  <li><a href="#recommendations" id="toc-recommendations" class="nav-link" data-scroll-target="#recommendations">Recommendations</a></li>
  </ul></li>
  <li><a href="#methodology-overview" id="toc-methodology-overview" class="nav-link" data-scroll-target="#methodology-overview">Methodology overview</a>
  <ul class="collapse">
  <li><a href="#model-description" id="toc-model-description" class="nav-link" data-scroll-target="#model-description">Model description</a></li>
  <li><a href="#metric" id="toc-metric" class="nav-link" data-scroll-target="#metric">Metric</a></li>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a></li>
  <li><a href="#exploratory-data-analysis" id="toc-exploratory-data-analysis" class="nav-link" data-scroll-target="#exploratory-data-analysis">Exploratory data analysis</a></li>
  <li><a href="#preprocessing" id="toc-preprocessing" class="nav-link" data-scroll-target="#preprocessing">Preprocessing</a></li>
  <li><a href="#final-model-description-segmentation-model-with-encoder-and-decoder" id="toc-final-model-description-segmentation-model-with-encoder-and-decoder" class="nav-link" data-scroll-target="#final-model-description-segmentation-model-with-encoder-and-decoder">Final Model Description: Segmentation model with encoder and decoder</a></li>
  <li><a href="#post-processing" id="toc-post-processing" class="nav-link" data-scroll-target="#post-processing">Post processing</a></li>
  <li><a href="#validation" id="toc-validation" class="nav-link" data-scroll-target="#validation">Validation</a></li>
  <li><a href="#notable-experiments" id="toc-notable-experiments" class="nav-link" data-scroll-target="#notable-experiments">Notable Experiments</a></li>
  <li><a href="#manual-post-processing-.014-validation-score" id="toc-manual-post-processing-.014-validation-score" class="nav-link" data-scroll-target="#manual-post-processing-.014-validation-score">Manual post processing: + .014 validation score</a></li>
  <li><a href="#test-score-.758" id="toc-test-score-.758" class="nav-link" data-scroll-target="#test-score-.758">Test score: .758</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/ChrisRichardMiles/sleep_state_detection/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">sleep_state_detection</h1>
</div>

<div>
  <div class="description">
    Determining people’s sleep state from wrist-worn accelerometer data
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<section id="problem-we-need-to-efficiently-track-sleep-states" class="level2">
<h2 class="anchored" data-anchor-id="problem-we-need-to-efficiently-track-sleep-states">Problem: We need to efficiently track sleep states</h2>
<p>Sleep is very important to human health. In order for researchers to properly study sleep they need to be able to accurately measure when people fall asleep and wake up. Research has been challenging “due to the lack of naturalistic data capture alongside accurate annotation. If data science could help researchers better analyze wrist-worn accelerometer data for sleep monitoring, sleep experts could more easily conduct large-scale studies of sleep, thus improving the understanding of sleep’s importance and function.” (Esper et al., 2023). Consumers could also benefit by being able to track their own sleep habits with a cheap wearable device.</p>
</section>
<section id="deliverables" class="level2">
<h2 class="anchored" data-anchor-id="deliverables">Deliverables</h2>
<ul>
<li>A model that takes in wrist-worn accelerometer data and predicts when sleep onset and wakeup times are located.</li>
<li>A report and slide deck outlining process, outcomes, and recommendations</li>
</ul>
</section>
<section id="stakeholders" class="level2">
<h2 class="anchored" data-anchor-id="stakeholders">Stakeholders</h2>
<p>Researchers who study sleep and companies who would like to use accelerometer data to track sleep to help people improve their health.</p>
</section>
<section id="proposed-solution" class="level2">
<h2 class="anchored" data-anchor-id="proposed-solution">Proposed solution:</h2>
<p>A deep learning model that takes in accelerometer data and outputs predicted “onset” and “wakeup” events along with confidence scores between 0 and 1. We treat this as a segmentation problem, segmenting out the sleep period from the awake period while also predicting the transition time.</p>
<p>Baseline solution started with code from this repo under an MIT license: https://github.com/tubo213/kaggle-child-mind-institute-detect-sleep-states/tree/main</p>
<section id="recommendations" class="level3">
<h3 class="anchored" data-anchor-id="recommendations">Recommendations</h3>
<ol type="1">
<li>Use these predictions to automatically annotate sleep onset and wake-up times.</li>
<li>Utilize these annotations in the context of studying sleep and its overall health effects.</li>
<li>Apply the annotations in a business context to help individuals understand their own sleep patterns and how they affect their health.</li>
</ol>
</section>
</section>
<section id="methodology-overview" class="level2">
<h2 class="anchored" data-anchor-id="methodology-overview">Methodology overview</h2>
<section id="model-description" class="level3">
<h3 class="anchored" data-anchor-id="model-description">Model description</h3>
<ul>
<li><p><strong>Model inputs</strong> Multi-day accelerometer data in 5 second steps.can.</p></li>
<li><p><strong>Model outputs</strong> A list of time steps and probabilities that they contain an “onset” or “wakeup” events</p></li>
</ul>
</section>
<section id="metric" class="level3">
<h3 class="anchored" data-anchor-id="metric">Metric</h3>
<p>Submissions are evaluated on the average precision of detected events, averaged over timestamp error tolerance thresholds, averaged over event classes.</p>
<p>Detections are matched to ground-truth events within error tolerances, with ambiguities resolved in order of decreasing confidence. For both event classes, we use error tolerance thresholds of 1, 3, 5, 7.5, 10, 12.5, 15, 20, 25, 30 in minutes, or 12, 36, 60, 90, 120, 150, 180, 240, 300, 360 in steps.</p>
<section id="detailed-description" class="level4">
<h4 class="anchored" data-anchor-id="detailed-description"><strong>Detailed Description</strong></h4>
<p><strong>Evaluation proceeds in three steps:</strong></p>
<p><strong>Assignment</strong> - Predicted events are matched with ground-truth events.</p>
<p><strong>Scoring</strong> - Each group of predictions is scored against its corresponding group of ground-truth events via Average Precision.</p>
<p><strong>Reduction</strong> - The multiple AP scores are averaged to produce a single overall score.</p>
<p><strong>Assignment</strong></p>
<p>For each set of predictions and ground-truths within the same event x tolerance x series_id group, we match each ground-truth to the highest-confidence unmatched prediction occurring within the allowed tolerance.</p>
<p>Some ground-truths may not be matched to a prediction and some predictions may not be matched to a ground-truth. They will still be accounted for in the scoring, however.</p>
<p><strong>Scoring</strong></p>
<p>Collecting the events within each series_id, we compute an Average Precision score for each event x tolerance group. The average precision score is the area under the precision-recall curve generated by decreasing confidence score thresholds over the predictions. In this calculation, matched predictions over the threshold are scored as TP and unmatched predictions as FP. Unmatched ground-truths are scored as FN.</p>
<p><strong>Reduction</strong></p>
<p>The final score is the average of the above AP scores, first averaged over tolerance, then over event.</p>
</section>
</section>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p>The dataset comprises about 500 multi-day recordings of wrist-worn accelerometer data annotated with two event types: onset, the beginning of sleep, and wakeup, the end of sleep.</p>
<p>Though each series is a continuous recording, there may be periods in the series when the accelerometer device was removed. These period are determined as those where suspiciously little variation in the accelerometer signals occur over an extended period of time, which is unrealistic for typical human participants. Events are not annotated for these periods, and you should attempt to refrain from making event predictions during these periods: an event prediction will be scored as false positive (Esper et al., 2023).</p>
<section id="files-and-field-descriptions" class="level4">
<h4 class="anchored" data-anchor-id="files-and-field-descriptions">Files and Field Descriptions</h4>
<ul>
<li><strong>train_series.parquet</strong> - Series to be used as training data. Each series is a continuous recording of accelerometer data for a single subject spanning many days.
<ul>
<li><strong>series_id</strong> - Unique identifier for each accelerometer series.</li>
<li><strong>step</strong> - An integer timestep for each observation within a series.</li>
<li><strong>timestamp</strong> - A corresponding datetime with ISO 8601 format <code>%Y-%m-%dT%H:%M:%S%z</code>.</li>
<li><strong>anglez</strong> - As calculated and described by the GGIR package, z-angle is a metric derived from individual accelerometer components that is commonly used in sleep detection, and refers to the angle of the arm relative to the vertical axis of the body.</li>
<li><strong>enmo</strong> - As calculated and described by the GGIR package, ENMO is the Euclidean Norm Minus One of all accelerometer signals, with negative values rounded to zero. While no standard measure of acceleration exists in this space, this is one of the several commonly computed features.</li>
</ul></li>
<li><strong>train_events.csv</strong> - Sleep logs for series in the training set recording onset and wake events.
<ul>
<li><strong>series_id</strong> - Unique identifier for each series of accelerometer data in <code>train_series.parquet</code>.</li>
<li><strong>night</strong> - An enumeration of potential onset / wakeup event pairs. At most one pair of events can occur for each night.</li>
<li><strong>event</strong> - The type of event, whether onset or wakeup.</li>
<li><strong>step and timestamp</strong> - The recorded time of occurrence of the event in the accelerometer series.</li>
</ul></li>
</ul>
</section>
</section>
<section id="exploratory-data-analysis" class="level3">
<h3 class="anchored" data-anchor-id="exploratory-data-analysis">Exploratory data analysis</h3>
<ul>
<li>No missing values for enmo and anglez columns</li>
<li>About one third of the nights do not have “onset” or “wakeup” annotations. This should be due to the person taking the accelerometer off, which can be inferred since the anglez range becomes very small during these times.</li>
<li>There a few nights for each person where there is only one event annotated.</li>
<li>During the sleep durations, The enmo values become much smaller and also less volatile, especially in the beginning of the sleep cycle. Similarly, the anglez values have less rapid fluctuations.</li>
</ul>
</section>
<section id="preprocessing" class="level3">
<h3 class="anchored" data-anchor-id="preprocessing">Preprocessing</h3>
<p><strong>Features</strong> - <strong>shape</strong>: (n_features, <code>cfg.duration</code>), (10, 5760) in the current best model - <strong>Sine and cosine components for:</strong> - Hour of the day (<code>hour_sin</code>, <code>hour_cos</code>) - Month of the year (<code>month_sin</code>, <code>month_cos</code>) - Minute of the hour (<code>minute_sin</code>, <code>minute_cos</code>) - Angle (<code>anglez_sin</code>, <code>anglez_cos</code>) - <strong>Differences between consecutive values for:</strong> - Angle (<code>anglez_diff</code>) - ENMO (<code>enmo_diff</code>) - <strong>Rolling medians for differences with a window size of 5 * 12 for:</strong> - Angle (<code>anglez_diff_rolling_median</code>) - ENMO (<code>enmo_diff_rolling_median</code>) - <strong>Reverse rolling medians for differences with a window size of 5 * 12 for:</strong> - Angle (<code>anglez_diff_rolling_median_reverse</code>) - ENMO (<code>enmo_diff_rolling_median_reverse</code>)</p>
<p><strong>Labels</strong> - <strong>shape</strong>: (<code>cfg.duration</code> / <code>cfg.downsample_rate</code>, 3), (1920, 3) in the current best model - 3 values are (is_asleep (0 or 1), onset, wakeup) - Either onset, wakeup, or background (no label) are present in the label - If background then all values are 0 for all 1920 steps - If onset or wakeup, the onset or wakeup are converted to gaussian labels, where the label is still one at the annotated time step, but there are also soft labels around the time step following a normal distribution.</p>
</section>
<section id="final-model-description-segmentation-model-with-encoder-and-decoder" class="level3">
<h3 class="anchored" data-anchor-id="final-model-description-segmentation-model-with-encoder-and-decoder">Final Model Description: Segmentation model with encoder and decoder</h3>
<ul>
<li>LSTM feature extractor</li>
<li>Unet decoder</li>
</ul>
</section>
<section id="post-processing" class="level3">
<h3 class="anchored" data-anchor-id="post-processing">Post processing</h3>
<p>For each event, onset and wakeup, we find peak predictions from our segmentation model make those our only predictions.</p>
</section>
<section id="validation" class="level3">
<h3 class="anchored" data-anchor-id="validation">Validation</h3>
<ul>
<li>20% validation set split for valid_set 1</li>
<li>Kaggle public leader board for valid_set 2</li>
<li>Kaggle private leader board for final test set</li>
</ul>
</section>
<section id="notable-experiments" class="level3">
<h3 class="anchored" data-anchor-id="notable-experiments">Notable Experiments</h3>
<table class="table">
<colgroup>
<col style="width: 36%">
<col style="width: 48%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th>Model</th>
<th>Brief Description</th>
<th>Valid_1 Score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Baseline</td>
<td>Config defaults</td>
<td>0.74</td>
</tr>
<tr class="even">
<td>v1_ds3</td>
<td>downsample_rate 2 to 3</td>
<td>0.7546</td>
</tr>
<tr class="odd">
<td>v2_ds3</td>
<td>added rolling median features</td>
<td>0.7565</td>
</tr>
<tr class="even">
<td>v2_ds3_fe_LSTMFeatureExtractor</td>
<td>Chosen Model</td>
<td>0.7598</td>
</tr>
</tbody>
</table>
</section>
<section id="manual-post-processing-.014-validation-score" class="level3">
<h3 class="anchored" data-anchor-id="manual-post-processing-.014-validation-score">Manual post processing: + .014 validation score</h3>
<p>In order to improve the metric, I visually inspected the predictions compared to the ground truth and tried to find simple methods to adjust predictions to improve scores.</p>
<p><strong>NOTE</strong> These adjustments are done sequentially, so optimized parameters may differ if the order is changed</p>
<table class="table">
<colgroup>
<col style="width: 16%">
<col style="width: 69%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th>Technique</th>
<th>Brief Description</th>
<th>valid_1 score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Lower threshold</td>
<td>threshold == .005</td>
<td>.765</td>
</tr>
<tr class="even">
<td>filter_by_min_max_th</td>
<td>Remove all predictions for a night where the min(max of onset and wakup score) &lt; <code>th</code> == .03</td>
<td>.767</td>
</tr>
<tr class="odd">
<td>filter_(onset of wakeup)_ threshold</td>
<td>Per night, if max is above .82, only keep max prediction</td>
<td>.768</td>
</tr>
<tr class="even">
<td>filter_max_score_by_night</td>
<td>Per night, eliminate all predictions if max is not above <code>th</code>=.03</td>
<td>.769</td>
</tr>
<tr class="odd">
<td>inflate_max_wakeup</td>
<td>Per night, find max wakeup score and inflate it by <code>multiplier</code> = 3.2</td>
<td>.771</td>
</tr>
<tr class="even">
<td>inflate_max_onset</td>
<td>Per night, find max wakeup score and inflate it by <code>multiplier</code> = 13.4</td>
<td>.774</td>
</tr>
</tbody>
</table>
</section>
<section id="test-score-.758" class="level3">
<h3 class="anchored" data-anchor-id="test-score-.758">Test score: .758</h3>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">References</h3>
<p>Nathalia Esper, Maggie Demkin, Ryan Hoolbrok, Yuki Kotani, Larissa Hunt, Andrew Leroux, Vincent van Hees, Vadim Zipunnikov, Kathleen Merikangas, Michael Milham, Alexandre Franco, Gregory Kiar. (2023). Child Mind Institute - Detect Sleep States. Kaggle. https://kaggle.com/competitions/child-mind-institute-detect-sleep-states</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/ChrisRichardMiles/sleep_state_detection/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>